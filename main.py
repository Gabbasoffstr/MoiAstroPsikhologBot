from aiogram import Bot, Dispatcher, types, executor
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
import logging, os, requests, openai
from flatlib.datetime import Datetime
from flatlib.geopos import GeoPos
from flatlib.chart import Chart
from fpdf import FPDF
from dotenv import load_dotenv
from timezonefinder import TimezoneFinder
import pytz
from datetime import datetime

load_dotenv()

API_TOKEN = os.getenv("API_TOKEN")
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
OPENCAGE_API_KEY = os.getenv("OPENCAGE_API_KEY")

bot = Bot(token=API_TOKEN)
dp = Dispatcher(bot)
openai.api_key = OPENAI_API_KEY

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –≤ —Ñ–∞–π–ª –∏ –∫–æ–Ω—Å–æ–ª—å
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.FileHandler("bot.log", mode="a", encoding="utf-8"),
        logging.StreamHandler()
    ]
)

kb = ReplyKeyboardMarkup(resize_keyboard=True, row_width=1).add(
    KeyboardButton("üöÄ –ù–∞—á–∞—Ç—å —Ä–∞—Å—á—ë—Ç"),
    KeyboardButton("üìä –ü—Ä–∏–º–µ—Ä –ø–ª–∞—Ç–Ω–æ–≥–æ –æ—Ç—á—ë—Ç–∞")
)

main_kb = ReplyKeyboardMarkup(resize_keyboard=True, row_width=1).add(
    "üîÆ –†–∞—Å—Å—á–∏—Ç–∞—Ç—å", "üìÑ –°–∫–∞—á–∞—Ç—å PDF", "üìÑ –ó–∞–∫–∞–∑–∞—Ç—å –ø–æ–¥—Ä–æ–±–Ω—ã–π –æ—Ç—á—ë—Ç"
)

users = {}
admin_id = 7943520249

def decimal_to_dms_str(degree, is_lat=True):
    d = int(abs(degree))
    m = int((abs(degree) - d) * 60)
    suffix = 'n' if is_lat and degree >= 0 else 's' if is_lat else 'e' if degree >= 0 else 'w'
    return f"{d}{suffix}{str(m).zfill(2)}"

def get_house_manually(chart, lon):
    """–†—É—á–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–æ–º–∞ –ø–æ –¥–æ–ª–≥–æ—Ç–µ."""
    try:
        for house in chart.houses:
            start_lon = house.lon
            end_lon = (house.lon + house.size) % 360
            if start_lon <= end_lon:
                if start_lon <= lon < end_lon:
                    return house.id
            else:
                if lon >= start_lon or lon < end_lon:
                    return house.id
        return "?"
    except Exception as e:
        logging.error(f"Error in get_house_manually with longitude {lon}: {e}")
        return "?"

def get_aspects(chart, planet_names):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –∞—Å–ø–µ–∫—Ç–æ–≤ –º–µ–∂–¥—É –ø–ª–∞–Ω–µ—Ç–∞–º–∏."""
    aspects = []
    try:
        for i, p1 in enumerate(planet_names):
            obj1 = chart.get(p1)
            for j in range(i + 1, len(planet_names)):
                p2 = planet_names[j]
                obj2 = chart.get(p2)
                diff = abs(obj1.lon - obj2.lon)
                diff = diff if diff <= 180 else 360 - diff

                if abs(diff - 0) <= 5:
                    aspects.append((p1, p2, diff, "—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ"))
                elif abs(diff - 60) <= 5:
                    aspects.append((p1, p2, diff, "—Å–µ–∫—Å—Ç–∏–ª—å"))
                elif abs(diff - 90) <= 5:
                    aspects.append((p1, p2, diff, "–∫–≤–∞–¥—Ä–∞—Ç"))
                elif abs(diff - 120) <= 5:
                    aspects.append((p1, p2, diff, "—Ç—Ä–∏–≥–æ–Ω"))
                elif abs(diff - 180) <= 5:
                    aspects.append((p1, p2, diff, "–æ–ø–ø–æ–∑–∏—Ü–∏—è"))
        return aspects
    except Exception as e:
        logging.error(f"Error in get_aspects: {e}")
        return []

@dp.message_handler(commands=["start"])
async def start(message: types.Message):
    await message.answer(
        "üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ *–ú–æ—è –ù–∞—Ç–∞–ª—å–Ω–∞—è –ö–∞—Ä—Ç–∞*! –ù–∞–∂–º–∏ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å —Ä–∞—Å—á—ë—Ç.",
        reply_markup=kb,
        parse_mode="Markdown"
    )

@dp.message_handler(lambda m: m.text == "üöÄ –ù–∞—á–∞—Ç—å —Ä–∞—Å—á—ë—Ç")
async def begin(message: types.Message):
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –¥–∞–Ω–Ω—ã–µ: –î–î.–ú–ú.–ì–ì–ì–ì, –ß–ß:–ú–ú, –ì–æ—Ä–æ–¥", reply_markup=main_kb)

@dp.message_handler(lambda m: m.text == "üìä –ü—Ä–∏–º–µ—Ä –ø–ª–∞—Ç–Ω–æ–≥–æ –æ—Ç—á—ë—Ç–∞")
async def send_example_report(message: types.Message):
    try:
        with open("example_paid_astrology_report.pdf", "rb") as f:
            await message.answer_document(f, caption="üìò –ü—Ä–∏–º–µ—Ä –ø–ª–∞—Ç–Ω–æ–≥–æ –æ—Ç—á—ë—Ç–∞")
    except FileNotFoundError:
        await message.answer("‚ö†Ô∏è –ü—Ä–∏–º–µ—Ä –æ—Ç—á—ë—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω. –û–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")

@dp.message_handler(lambda m: m.text == "üìÑ –°–∫–∞—á–∞—Ç—å PDF")
async def pdf(message: types.Message):
    user_id = message.from_user.id
    if user_id in users and "pdf" in users[user_id]:
        with open(users[user_id]["pdf"], "rb") as f:
            await message.answer_document(f)
    else:
        await message.answer("–°–Ω–∞—á–∞–ª–∞ —Ä–∞—Å—Å—á–∏—Ç–∞–π—Ç–µ –∫–∞—Ä—Ç—É.")

@dp.message_handler(lambda m: m.text == "üîÆ –†–∞—Å—Å—á–∏—Ç–∞—Ç—å" or "," in m.text)
async def calculate(message: types.Message):
    try:
        user_id = message.from_user.id
        parts = [x.strip() for x in message.text.split(",")]
        if len(parts) != 3:
            await message.answer("‚ö†Ô∏è –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –í–≤–µ–¥–∏—Ç–µ: –î–î.–ú–ú.–ì–ì–ì–ì, –ß–ß:–ú–ú, –ì–æ—Ä–æ–¥")
            return

        date_str, time_str, city = parts
        logging.info(f"Input: {date_str}, {time_str}, {city}")
        geo = requests.get(f"https://api.opencagedata.com/geocode/v1/json?q={city}&key={OPENCAGE_API_KEY}").json()
        if not geo.get("results"):
            await message.answer("‚ùå –ì–æ—Ä–æ–¥ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
            return

        lat = geo["results"][0]["geometry"]["lat"]
        lon = geo["results"][0]["geometry"]["lng"]
        lat_str = decimal_to_dms_str(lat, True)
        lon_str = decimal_to_dms_str(lon, False)
        logging.info(f"Coordinates: lat={lat_str}, lon={lon_str}")

        tf = TimezoneFinder()
        timezone_str = tf.timezone_at(lat=lat, lng=lon)
        if timezone_str is None:
            await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —á–∞—Å–æ–≤–æ–π –ø–æ—è—Å.")
            return
        logging.info(f"Timezone: {timezone_str}")

        timezone = pytz.timezone(timezone_str)
        dt_input = datetime.strptime(f"{date_str} {time_str}", "%d.%m.%Y %H:%M")
        dt_local = timezone.localize(dt_input)
        dt_utc = dt_local.astimezone(pytz.utc)
        dt = Datetime(dt_utc.strftime("%Y/%m/%d"), dt_utc.strftime("%H:%M"), "+00:00")
        logging.info(f"UTC Time: {dt_utc}")

        chart = Chart(dt, GeoPos(lat_str, lon_str))  # –ë–µ–∑ hsys
        logging.info(f"Chart created with houses: {chart.houses}")

        planet_names = ["Sun", "Moon", "Mercury", "Venus", "Mars"]
        summary = []
        planet_info = {}
        aspects = get_aspects(chart, planet_names)
        aspects_by_planet = {p: [] for p in planet_names}
        for p1, p2, diff, aspect_name in aspects:
            aspects_by_planet[p1].append(f"{p1} {aspect_name} {p2} ({round(diff, 1)}¬∞)")
            aspects_by_planet[p2].append(f"{p2} {aspect_name} {p1} ({round(diff, 1)}¬∞)")
        logging.info(f"Aspects calculated: {aspects}")

        for p in planet_names:
            obj = chart.get(p)
            sign, deg = obj.sign, obj.lon
            house = get_house_manually(chart, deg)
            logging.info(f"Processing planet: {p}, Sign: {sign}, Deg: {deg}, House: {house}")

            # GPT –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è
            prompt = f"{p} –≤ –∑–Ω–∞–∫–µ {sign}, –¥–æ–º {house}, –¥–æ–ª–≥–æ—Ç–∞ {deg:.2f}. –î–∞–π –∫—Ä–∞—Ç–∫—É—é –∞—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫—É—é –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—é."
            try:
                res = openai.ChatCompletion.create(
                    model="gpt-4",
                    messages=[{"role": "user", "content": prompt}],
                    temperature=0.7,
                    max_tokens=500
                )
                reply = res.choices[0].message.content.strip()
            except Exception as e:
                logging.error(f"Error in GPT interpretation for {p}: {e}")
                reply = "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—é."

            await message.answer(f"üîç {p} –≤ {sign}, –¥–æ–º {house}")
            await message.answer(f"üì© {reply}")
            aspect_text = "\n".join([f"‚Ä¢ {a}" for a in aspects_by_planet[p]]) if aspects_by_planet[p] else "‚Ä¢ –ù–µ—Ç —Ç–æ—á–Ω—ã—Ö –∞—Å–ø–µ–∫—Ç–æ–≤"
            await message.answer(f"üìê –ê—Å–ø–µ–∫—Ç—ã:\n{aspect_text}")

            summary.append(f"{p} –≤ {sign}, –¥–æ–º {house}:\nüìê –ê—Å–ø–µ–∫—Ç—ã:\n{aspect_text}\nüì© {reply}")
            planet_info[p] = {
                "sign": sign,
                "degree": deg,
                "house": house
            }

        pdf = FPDF()
        pdf.add_page()
        pdf.add_font("DejaVu", "", "DejaVuSans.ttf", uni=True)
        pdf.set_font("DejaVu", size=12)
        for line in summary:
            pdf.multi_cell(0, 10, line)
        pdf_path = f"user_{user_id}_report.pdf"
        pdf.output(pdf_path)
        logging.info(f"PDF created: {pdf_path}")

        users[user_id] = {
            "pdf": pdf_path,
            "planets": planet_info,
            "lat": lat,
            "lon": lon,
            "city": city,
            "date_str": date_str,
            "time_str": time_str,
            "dt_utc": dt_utc
        }
        logging.info(f"User data saved: {users[user_id]}")

        await message.answer("‚úÖ –ì–æ—Ç–æ–≤–æ! –¢–µ–ø–µ—Ä—å –º–æ–∂–Ω–æ –∑–∞–∫–∞–∑–∞—Ç—å üìÑ –ø–æ–¥—Ä–æ–±–Ω—ã–π –æ—Ç—á—ë—Ç.")
    except Exception as e:
        logging.error(f"Error in calculate: {e}", exc_info=True)
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞: {e}")

@dp.message_handler(lambda m: m.text == "üìÑ –ó–∞–∫–∞–∑–∞—Ç—å –ø–æ–¥—Ä–æ–±–Ω—ã–π –æ—Ç—á—ë—Ç")
async def send_detailed_parts(message: types.Message):
    user_id = message.from_user.id
    user_data = users.get(user_id)
    if not user_data:
        await message.answer("‚ùó –°–Ω–∞—á–∞–ª–∞ —Å–¥–µ–ª–∞–π—Ç–µ —Ä–∞—Å—á—ë—Ç.")
        return

    first_name = message.from_user.first_name or "–î–æ—Ä–æ–≥–æ–π –¥—Ä—É–≥"
    date_str = user_data["date_str"]
    time_str = user_data["time_str"]
    city = user_data["city"]
    dt_utc_str = user_data["dt_utc"].strftime("%Y-%m-%d %H:%M")
    lat = user_data["lat"]
    lon = user_data["lon"]

    planet_lines = "\n".join([
        f"{p}: {info['sign']} ({round(info['degree'], 2)}¬∞), –¥–æ–º: {info['house']}"
        for p, info in user_data["planets"].items()
    ])

    header = f"""
–ò–º—è: {first_name}
–î–∞—Ç–∞: {date_str}
–í—Ä–µ–º—è: {time_str}
–ì–æ—Ä–æ–¥: {city}
UTC: {dt_utc_str}
–®–∏—Ä–æ—Ç–∞: {lat}
–î–æ–ª–≥–æ—Ç–∞: {lon}
–ü–ª–∞–Ω–µ—Ç—ã:
{planet_lines}
"""

    sections = [
        ("–ü–ª–∞–Ω–µ—Ç—ã", "–ü–æ–¥—Ä–æ–±–Ω–æ –æ–ø–∏—à–∏ –≤–ª–∏—è–Ω–∏–µ –ø–ª–∞–Ω–µ—Ç –Ω–∞ –ª–∏—á–Ω–æ—Å—Ç—å, –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã, –¥–∞—Ä—ã."),
        ("–î–æ–º–∞", "–†–∞—Å–ø–∏—à–∏, –∫–∞–∫ –¥–æ–º–∞ –≤–ª–∏—è—é—Ç –Ω–∞ –∂–∏–∑–Ω—å, –æ—Å–æ–±–µ–Ω–Ω–æ –≤ —Å–æ—á–µ—Ç–∞–Ω–∏–∏ —Å –ø–ª–∞–Ω–µ—Ç–∞–º–∏."),
        ("–ê—Å–ø–µ–∫—Ç—ã", "–û–ø–∏—à–∏ —Ç—Ä–∏ –∑–Ω–∞—á–∏–º—ã—Ö –∞—Å–ø–µ–∫—Ç–∞ –º–µ–∂–¥—É –ø–ª–∞–Ω–µ—Ç–∞–º–∏."),
        ("–ê—Å—Ü–µ–Ω–¥–µ–Ω—Ç", "–û–ø—Ä–µ–¥–µ–ª–∏ –∏ –æ—Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏–∑—É–π –ê—Å—Ü–µ–Ω–¥–µ–Ω—Ç."),
        ("–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏", "–î–∞–π —Å–æ–≤–µ—Ç—ã –ø–æ —Å–∞–º–æ—Ä–∞–∑–≤–∏—Ç–∏—é, –ª—é–±–≤–∏, –∫–∞—Ä—å–µ—Ä–µ."),
    ]

    for title, instruction in sections:
        prompt = f"""
–¢—ã –æ–ø—ã—Ç–Ω—ã–π –∞—Å—Ç—Ä–æ–ª–æ–≥-–ø—Å–∏—Ö–æ–ª–æ–≥. –ò—Å–ø–æ–ª—å–∑—É–π –¥–∞–Ω–Ω—ã–µ –Ω–∏–∂–µ –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞.

{header}

–ó–∞–¥–∞—á–∞: {instruction}
        """

        try:
            res = openai.ChatCompletion.create(
                model="gpt-4",
                messages=[{"role": "user", "content": prompt}],
                temperature=0.95,
                max_tokens=3000
            )
            content = res.choices[0].message.content.strip()

            pdf = FPDF()
            pdf.add_page()
            pdf.add_font("DejaVu", "", "DejaVuSans.ttf", uni=True)
            pdf.set_font("DejaVu", size=12)
            for paragraph in content.split("\n\n"):
                for line in paragraph.split("\n"):
                    pdf.multi_cell(0, 10, line)
                pdf.ln(3)

            filename = f"{user_id}_{title}.pdf"
            pdf.output(filename)
            with open(filename, "rb") as f:
                await message.answer_document(f, caption=f"üìò –û—Ç—á—ë—Ç: {title}")
        except Exception as e:
            logging.error(f"Error generating report {title}: {e}")
            await message.answer(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ {title}: {e}")

if __name__ == "__main__":
    executor.start_polling(dp, skip_updates=True)